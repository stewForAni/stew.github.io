<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面试总结 | CoolStew</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="面试知识点记录整理">
<meta property="og:type" content="article">
<meta property="og:title" content="面试总结">
<meta property="og:url" content="https://stewforani.github.io/2015/07/05/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="CoolStew">
<meta property="og:description" content="面试知识点记录整理">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2015-07-05T09:21:33.000Z">
<meta property="article:modified_time" content="2023-07-07T13:40:42.159Z">
<meta property="article:author" content="Stew">
<meta property="article:tag" content="interview">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="CoolStew" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CoolStew</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Android Blog &amp; Find Me Github@stewforani</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://stewforani.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面试总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2015/07/05/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2015-07-05T09:21:33.000Z" itemprop="datePublished">2015-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面试总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>面试知识点记录整理</p>
<span id="more"></span>

<hr>
<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>1.可以理解为一个环境中切换的不同场景，可以获取一些公共资源，例如资源文件，应用包信息等；可以启动 Activities, 注册广播监听器，发送广播等。</p>
<p>2.四大组件中只有 Activity，Service 继承了 Context，所以如果要算应用里的 Context 的实例数量，应该是 Activity 的实例个数 + Service 的实例个数 + Application 的实例个数。</p>
<p>3.BroadcastReceiver是没有Context的，onReceiver传进来的Context是注册该广播的Context ，而ContentProvider的Context是Application的Context。</p>
<p>4.ContextWrapper中的mBase变量是如何实例化的（分activity和application）<br>Activity:<br>ActivityThread#performLaunchActivity<br>ContextImpl appContext &#x3D; createBaseContextForActivity(r);<br>Application:<br>ActivityThread#performLaunchActivity<br>Application app &#x3D; r.packageInfo.makeApplicationInner(false, mInstrumentation);</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>1.一个线程可以有几个Looper？<br>只能有一个，不然调用Looper.prepare()会抛出运行时异常，提示“Only one Looper may be created per thread”</p>
<p>2.一个线程可以有几个Handler<br>可以创建无数个Handler，但是他们使用的消息队列都是同一个，也就是同一个Looper</p>
<p>3.同一个Looper是怎么区分不同的Handler的，换句话说，不同的Handler是怎么做到处理自己发出的消息的？<br>handler的enqueueMessage中，msg.target &#x3D; this，最后msg.target.dispatchMessage(msg)</p>
<p>4.Thread 若与 Looper 关联，将会是一一对应的关系，且关联后关系无法改变。<br>Looper 与 MessageQueue 是一一对应的关系。<br>Handler 与 Looper 是多对一的关系，创建 Handler 实例时要么提供一个 Looper 实例，要么使用当前线程有关联的Looper。</p>
<p>5.Handler的实现原理<br>Handler:负责消息的发送和处理<br>Message:消息对象，类似于链表的一个结点<br>MessageQueue:消息队列，用于存放消息对象的数据结构<br>Looper:消息队列的处理者<br>Handler发送消息时调用MessageQueue的enqueueMessage插入一条信息到MessageQueue,Looper不断轮询调用MeaasgaQueue的next方法 如果发现message就调用handler的dispatchMessage，dispatchMessage被成功调用，接着调用handlerMessage()。</p>
<p>6.子线程中不能直接new一个Handler，因为Handler 的构造方法中，会通过Looper.myLooper()获取looper对象，如果为空，则抛出异常，主线程则因为在ActivityThread的main方法中有Looper.prepareMainLooper()</p>
<p>7.Handler导致的内存泄露原因及其解决方案<br>Java中非静态内部类和匿名内部类都会隐式持有当前类的外部引用<br>解决方案：<br>1.静态内部类 + 弱引用<br>private static class MyHandler extends Handler {<br>    &#x2F;&#x2F;弱引用，在垃圾回收时，activity可被回收<br>    private WeakReference<MainActivity> mWeakReference;<br>    public MyHandler(MainActivity activity) {<br>        mWeakReference &#x3D; new WeakReference&lt;&gt;(activity);<br>    }<br>    @Override<br>    public void handleMessage(@NonNull Message msg) {<br>        super.handleMessage(msg);<br>        &#x2F;&#x2F;之所以引用activity对象，是因为更新UI需要activity对象<br>    }<br>}<br>2.在Activity销毁时，清空Handler中未执行或正在执行的Callback以及Message：<br>protected void onDestroy() {<br>    super.onDestroy();<br>    &#x2F;&#x2F;清空handler管道和队列<br>    mHandler.removeCallbacksAndMessages(null);<br>}</p>
<p>8.Message对象创建的方式<br>Message msg &#x3D; new Message()<br>Message msg &#x3D; Message.obtain()&#x2F;&#x2F;避免重复Message创建对象</p>
<p>9.Handler的post与sendMessage的区别<br>sendMessage（适用多条件判断）<br>sendMessage-sendMessageAtTime-enqueueMessage<br>post（适用单一场景）<br>post-sendMessageDelayed-sendMessageAtTime-enqueueMessage<br>其中sendMessageDelayed中有sendMessageDelayed(getPostMessage(r), 0)<br>private static Message getPostMessage(Runnable r) {<br>    Message m &#x3D; Message.obtain();<br>    m.callback &#x3D; r;<br>    return m;<br>}</p>
<p>10.MessageQueue是什么数据结构<br>消息是按照时间先后顺序来存储的单链表</p>
<p>11.IdleHandler<br>Looper.getMainLooper().getQueue().addIdleHandler(new MessageQueue.IdleHandler() {<br>    @Override<br>    public boolean queueIdle() {<br>        &#x2F;&#x2F; UI第一帧绘制完成（可以理解为页面可见）<br>        return false;<br>    }<br>});</p>
<p>12.消息屏障<br>message.target &#x3D;&#x3D;null为屏障消息,遇到target为null的Message，说明是同步屏障，循环遍历找出一条异步消息，然后处理<br>1、Handler构造方法中传入async参数，设置为true，使用此Handler添加的Message都是异步的<br>2、创建Message对象时，直接调用setAsynchronous(true)</p>
<h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><p>1.Glide的缓存机制，主要分为2种缓存，一种是内存缓存，一种是磁盘缓存。<br>内存缓存的原因是：防止应用重复将图片读入到内存，造成内存资源浪费。<br>磁盘缓存的原因是：防止应用重复的从网络或者其他地方下载和读取数据。</p>
<p>2.三级缓存：弱引用缓存-》Lru算法缓存-》磁盘缓存（弱引用作用：lru size比较小，界面图片又很多，导致还在显示的图片被lru删除）</p>
<p>3.弱引用缓存使用hashmap，LruCache使用LinkedHashMap，LinkedHashMap 继承HashMap，在 HashMap的基础上，新增了双向链表结构，每次访问数据的时候，会更新被访问的数据的链表指针，具体就是先在链表中删除该节点，然后添加到链表头header之前，这样就保证了链表头header节点之前的数据都是最近访问的（从链表中删除并不是真的删除数据，只是移动链表指针，数据本身在map中的位置是不变的）</p>
<p>4.图片尺寸不一样，即使是同一张图，Glide也会下载两次，因为缓存Key的生成条件之一就是控件的长宽（4.9）（新版本好像只下载一次，对原图进行变换）</p>
<p>5.Glide会创建透明的fragment来感知生命周期，当 Activity、Fragment 等组件进入不可见，或者已经销毁的时候，Glide 会停止加载资源（Glide.with(this)绑定了Activity的生命周期。在Activity内新建了一个无UI的Fragment）</p>
<p>6.DiskCacheStrategy.DATA&#x2F;&#x2F; 表示只缓存原始图片，DiskCacheStrategy.RESOURCE&#x2F;&#x2F; 表示只缓存转换过后的图片(缩放等操作)</p>
<p>7.图片压缩：inSampleSize进行尺寸优化，inpreferredconfig进行RGB优化，inBitmap进行bitmap复用</p>
<p>8.BitmapRegionDecoder可用于加载大图，滑动时内存抖动，卡顿现象比较明显</p>
<h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><p>setAdapter中会注册观察者，notifyxxx中被观察者会通知注册的观察者，执行相应的方法</p>
<p>viewholder主要是为了hold view来复用，避免大量findViewById操作</p>
<p>ViewHolder中使用SparseArray替代HashMap存储viewId，数据量小的时候SparseArray性能略好，没有装箱</p>
<p>SnapHelper帮助RV实现类似viewpager的效果，横向效果</p>
<p>建议在onCreateViewHolder中使用listener.onItemClick(view, holder.getLayoutPosition())来实现点击事件</p>
<p>如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout 浪费资源</p>
<p>可以通过 ((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false); 把默认动画关闭提升效率。</p>
<p>tryGetViewHolderForPositionByDeadline  获取缓存的方法</p>
<p>dispatchLayoutStep1()预布局<br>dispatchLayoutStep2()真正布局<br>dispatchLayoutStep3()保存和触发有关动画的信息，相关清理等工作</p>
<p>RecyclerView滚动时先填充后缓存</p>
<p>1.notifyItemRemoved之后，pre-layout预布局，提前加载未显示底部item，便于整体的上移动画</p>
<p>2.CachedView的默认大小为2，可以通过 setItemViewCacheSize 方法修改它的值，RecycledViewPool默认大小为5，可以通过<br>RecyclerView.getRecycledViewPool().setMaxRecycledViews(int viewType, int max)来修改</p>
<p>3.RecycledViewPool取出后需要bindViewHolder，CachedView不需要</p>
<p>4.数据尽量异步处理，尽量将最优质的数据格式返回给UI线程</p>
<p>5.针对快速滑动事件，可以使用addOnScrollListener添加对快速滑动的监听，当用户快速滑动时，停止加载数据操作</p>
<p>6.如果ItemView的高度固定，可以使用setHasFixSize(true)。这样RecyclerView在onMeasure阶段可以直接计算出高度，不需要多次计算子ItemView的高度</p>
<p>7.manager.setSpanSizeLookup可以设置item列数</p>
<p>8.上拉加载更多数据，可以直接用notifyItemRangeInserted方法，不要用notifyDataSetChanged方法</p>
<p>9.在Layout的过程会通过LayoutManager.fill去将RecyclerView填满<br>fill会调用LayoutManager.layoutChunk去生成一个具体的ViewHolder<br>然后LayoutManager就会调用Recycler.getViewForPosition向Recycler去要ViewHolder，然后调用tryGetViewHolderForPositionByDeadline，里面涉及到各个缓存，如果还是没找到，则直接创建</p>
<p>10.mAttachedScrap &#x2F; mChangedScrap</p>
<p>11.notidyDataSetChanged() 会将屏幕中和离屏缓存 mCachedViews 中的 ViewHolder 全部标记为无效（RecyclerPool 中的 ViewHolder 本身已标记为无效）。在真正执行 RecyclerView#requestLayout() 刷新列表时，所有的 Item 都需要重新绑定数据，因此性能差。无效化体现在代码上即是为 ViewHolder 添加 FLAG_UPDATE 和 FLAG_INVALID 标志位</p>
<p>12.不管脱手还是跟手，真正滑动的地方：循环遍历子view，执行offsetTopAndBottom<br>RecyclerView 的脱手滚动（fling）是一段一段进行的，每一小段的滚动都被包裹在一个叫ViewFlinger的 Runnable 中。它会被抛到Choreographer中，作为动画任务暂存起来。待一下个垂直同步信号到来之时，被抛到主线程的消息队列中执行。</p>
<p>13.RecyclerView也把预拉取的实际工作委托给了一个名为GapWorker的类<br>UI线程空闲时才会执行，且必须在下一个Vsync信号到来之前<br>预加载的vh会缓存到cacheview中<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7181979065488769083">https://juejin.cn/post/7181979065488769083</a></p>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p>1.bitmap内存 &#x3D; 宽 x scale x 高 x scale x 每个像素字节大小<br>其中scale &#x3D; 设备dpi &#x2F; 对应文件夹dpi（scale针对图片）</p>
<p>2.px &#x3D; dp x (dpi &#x2F; 160)（此公式针对普通 dp px 转换）</p>
<p>3.bitmap内存优化：<br>options.inPreferredConfig &#x3D; Bitmap.Config.RGB_565;&#x2F;&#x2F;图片格式，一个像素占2字节<br>options.inSampleSize &#x3D; i;&#x2F;&#x2F;采样率，i不能小于1，隔i个像素采集一次数据<br>op.inMutable &#x3D; true;op.inBitmap &#x3D; reuseBitmap;&#x2F;&#x2F;复用<br>匿名共享内存，5.0以上已经禁止<br>bitmap.compress(Bitmap.CompressFormat.JPEG, 20, <br>new FileOutputStream(“sdcard&#x2F;result.jpg”));&#x2F;&#x2F;这种方式不好，容易失真</p>
<p>4.bitmap储存位置：<br>3.0 - 7.0 存在java堆<br>3.0之前，8.0及之后，存native堆</p>
<p>5.加载长图大图<br>推荐：Glide+SubsamplingScaleImageView<br><a target="_blank" rel="noopener" href="https://github.com/davemorrissey/subsampling-scale-image-view">https://github.com/davemorrissey/subsampling-scale-image-view</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6955427322291814431">https://juejin.cn/post/6955427322291814431</a></p>
<h3 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h3><p>1.webViewClient控制url跳转</p>
<p>2.webChromeClient可以处理网页加载进度</p>
<p>3.web.settings可以设置网页各项参数</p>
<p>4.想让当前webview加载通过，正确写法就是返回false：<br>public boolean shouldOverrideUrlLoading(final WebView view, final String url) {<br>    return false;<br>}<br>实测：android11，页面打开时不会调用shouldOverrideUrlLoading，但是点击当前页面内的超链接，会调用shouldOverrideUrlLoading</p>
<h3 id="io-amp-okio"><a href="#io-amp-okio" class="headerlink" title="io&amp;okio"></a>io&amp;okio</h3><p>传统io采用装饰者模式，写法繁琐，其中有个 FilterInputStream 类涉及到 装饰者和继承的问题<br>如果没有FilterInputStream，靠继承，那么会出现数不清的子类，造成类爆炸<br>所以这里采用继承不是好方法，而是采用组合的方法</p>
<p>关键点：不是通过继承，容易造成爆炸，而是通过组合，每个字类对应一个功能，然后多个功能组合起来使用</p>
<hr>
<p>source对应inputstream<br>sink对应outputstream</p>
<p>1.okio很方便是因为不需要嵌套很多装饰类，BufferedSink和BufferedSource已经满足大部分功能</p>
<p>2.Segment字面翻译就是片段，大小8k，Okio将数据也就是Buffer分割成一块块的片段，同时segment拥有前置节点和后置节点，构成一个双向循环链表，而Segment内部的数据是数组，兼具读写和插入</p>
<p>3.SegmentPool ，segment的对象池，池子的上限是64k，相当于8个segment，其中有next和bytecount两个内部变量，next这个节点可以看出SegmentPool是按照单链表的方式进行存储的，byteCount则是目前已有的大小。<br>回收和取对象都是加锁的，SegmentPool无论是回收和取对象都是在表头操作。</p>
<p>4.ByteString，内部有两变量，byte和string，所有转换无压力，空间换时间</p>
<p>5.Buffer是okio整个读和写的核心，RealBufferedSource 和 RealBufferedSink 实际上都只是一个代理，里面的操作全部都是通过Buffer来完成的</p>
<p>6.日志系统涉及到的写入问题，可以用mmap技术，比io性能高，在Android中可以将文件通过Java提供的MappedByteBuffer映射到内存，然后进行读写。微信的xlog模块mmap实现是基于C++代码实现<br>MappedByteBuffer 位于 Java NIO 包下，用于将文件内容映射到缓冲区，使用的即是 mmap 技术</p>
<p>也可以通过JNI调用C++方法</p>
<h3 id="okhttp"><a href="#okhttp" class="headerlink" title="okhttp"></a>okhttp</h3><h3 id="activity-amp-fragment"><a href="#activity-amp-fragment" class="headerlink" title="activity&amp;fragment"></a>activity&amp;fragment</h3><h3 id="view绘制-amp-view事件分发"><a href="#view绘制-amp-view事件分发" class="headerlink" title="view绘制&amp;view事件分发"></a>view绘制&amp;view事件分发</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://stewforani.github.io/2015/07/05/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" data-id="clj3vrr490000cfcac37036m8" data-title="面试总结" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/08/10/Android%20Expansion/libs%E5%92%8CjniLibs/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          libs和jniLibs
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Expansion/" rel="tag">Expansion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jetpack/" rel="tag">Jetpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Optimization/" rel="tag">Optimization</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/framework/" rel="tag">framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/" rel="tag">gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kotlin/" rel="tag">kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxjava/" rel="tag">rxjava</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Expansion/" style="font-size: 12px;">Expansion</a> <a href="/tags/Java/" style="font-size: 12px;">Java</a> <a href="/tags/Jetpack/" style="font-size: 14px;">Jetpack</a> <a href="/tags/Optimization/" style="font-size: 16px;">Optimization</a> <a href="/tags/algorithm/" style="font-size: 18px;">algorithm</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/framework/" style="font-size: 18px;">framework</a> <a href="/tags/gradle/" style="font-size: 12px;">gradle</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/kotlin/" style="font-size: 12px;">kotlin</a> <a href="/tags/rxjava/" style="font-size: 10px;">rxjava</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/23/Android%20Gradle/%E5%8F%91%E5%B8%83Gradle%E6%8F%92%E4%BB%B6(kotlin)/">发布Gradle插件(kotlin)</a>
          </li>
        
          <li>
            <a href="/2023/01/22/Android%20Gradle/%E5%8F%91%E5%B8%83Gradle%E6%8F%92%E4%BB%B6(java)/">发布Gradle插件(java)</a>
          </li>
        
          <li>
            <a href="/2023/01/21/Android%20Optimization/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/">组件化知识点记录</a>
          </li>
        
          <li>
            <a href="/2023/01/20/Android%20Gradle/Gradle%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/">Gradle知识点记录</a>
          </li>
        
          <li>
            <a href="/2022/10/26/Android%20Optimization/%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7/">性能工具</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Stew<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>